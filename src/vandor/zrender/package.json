{
  "_args": [
    [
      "zrender@https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
      "/Users/qiansr/TEST/3S/touping/src/vandor/node_modules/echarts"
    ]
  ],
  "_from": "https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
  "_id": "zrender@2.1.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/zrender",
  "_phantomChildren": {},
  "_requested": {
    "name": "zrender",
    "raw": "zrender@https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
    "rawSpec": "https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
    "scope": null,
    "spec": "https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
    "type": "remote"
  },
  "_requiredBy": [
    "/echarts"
  ],
  "_resolved": "https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
  "_shasum": "157e267287eddca805fed23d341cb7850dafe6d3",
  "_shrinkwrap": null,
  "_spec": "zrender@https://github.com/uooo/zrender/archive/2.1.1-webpack.tar.gz",
  "_where": "/Users/qiansr/TEST/3S/touping/src/vandor/node_modules/echarts",
  "bugs": {
    "url": "https://github.com/uooo/zrender/issues"
  },
  "dependencies": {},
  "description": "一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型，让canvas绘图大不同！",
  "devDependencies": {},
  "homepage": "https://ecomfe.github.com/zrender",
  "main": "zrender",
  "name": "zrender",
  "optionalDependencies": {},
  "readme": "ZRender\r\n=======\r\nhttp://ecomfe.github.com/zrender\r\n\r\n一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型，让canvas绘图大不同！\r\n\r\nArchitecture\r\n------------\r\nMVC核心封装实现图形仓库、视图渲染和交互控制：\r\n* Stroage(M) : shape数据CURD管理\r\n* Painter(V) : canvase元素生命周期管理，视图渲染，绘画，更新控制\r\n* Handler(C) : 事件交互处理，实现完整dom事件模拟封装\r\n* shape : 图形实体，分而治之的图形策略，可定义扩展\r\n* tool : 绘画扩展相关实用方法，工具及脚手架\r\n\r\n特色\r\n----\r\n### 简单\r\n无需canvas基础，精简的接口方法，符合AMD标准，易学易用。\r\n\r\n    require(\r\n        ['zrender/zrender'],\r\n        function(zrender) {\r\n            // just init to get a zrender Instance\r\n            var zr = zrender.init(document.getElementById('main'));\r\n            // zr can be used now!\r\n            ...\r\n        }\r\n    );\r\n\r\n### 数据驱动\r\n利用zrender绘图，你只需做的是定义图形数据，剩下的事情就交给zrender吧~\r\n\r\n哦，对了，差点忘记告诉你，只要在你定义图形数据时设置draggable属性为true，图形拖拽就已经可用了！\r\n\r\n    var CircleShape = require('zrender/shape/Circle');\r\n    zr.addShape(\r\n        new CircleShape({\r\n            style : {\r\n                x : 100,\r\n                y : 100,\r\n                r : 50,\r\n                color : 'rgba(220, 20, 60, 0.8)'\r\n            }\r\n        })\r\n    );\r\n    zr.render();\r\n    \r\n### 完整的事件封装\r\n用你再熟悉不过的dom事件模型去操作canvas里的图形元素是件很cool的事情~\r\n\r\n你不仅可以响应zrender全局事件，你甚至可以为在特定shape上添加特定事件，后续发生的一切都会按你想的那样去运行~\r\n\r\n    var CircleShape = require('zrender/shape/Circle');\r\n    zr.addShape(\r\n        new CircleShape({\r\n            style : {...},\r\n            // 图形元素上绑定事件\r\n            onmouseover : function(params) {\r\n                console.log('catch you!');\r\n            }\r\n        })\r\n    );\r\n    \r\n    // 全局事件\r\n    zr.on('click', function(params) {alert('Hello, zrender!')});\r\n    \r\n### 高效的分层刷新\r\n正如css中zlevel的作用一样，你可以定义把不同的shape分别放在不同的层中，这不仅实现了视觉上的上下覆盖，\r\n更重要的是当图形元素发生变化后的refresh将局限在发生了变化的图形层中，这在你利用zrender做各种动画效果时将十分有用，\r\n性能自然也更加出色~\r\n\r\n    zr.addShape(shapeA);    // shapeA.zlevel = 0; (default) \r\n    zr.addShape(shapeB);    // shapeB.zlevel = 1;\r\n    zr.render();\r\n    \r\n    zr.modShape(shapeB.id, {color:'red'}); \r\n    // Don't worry! Is merge!\r\n    \r\n    zr.refresh();  \r\n    // Just the level 1 canvas has been refresh~\r\n    \r\n### 丰富的图形选项\r\n当前内置多种图形元素（圆形、椭圆、圆环、扇形、矩形、多边形、直线、曲线、心形、水滴、路径、文字、图片。Will be more..），统一且丰富的图形属性充分满足你的个性化需求！\r\n\r\n    var CircleShape = require('zrender/shape/Circle');\r\n    var myShape = new CircleShape({\r\n        zlevel : 1,\r\n        style : {\r\n            ... // color | strokeColor | text | textFont | ...\r\n        },\r\n        draggable : true\r\n    });\r\n\r\n### 强大的动画支持\r\n提供promise式的动画接口和常用缓动函数，轻松实现各种动画需求~\r\n    \r\n    zr.addShape(newShape);\r\n    zr.render();\r\n    zr.animate(newShape.id)\r\n      .when(1000, { position : [300, 200] })\r\n      .when(2000, { position : [30, 400] })\r\n      .start('BounceOut');\r\n    \r\n### 易于扩展\r\n分而治之的图形定义策略允许你扩展自己独有的图形元素，你既可以完整实现三个接口方法（brush、drift、isCover），\r\n也可以通过base派生后仅实现你所关心的图形细节。\r\n\r\n    function MyShape() { ... }\r\n    \r\n    zr.addShape(\r\n        new MyShape({           // and use it!\r\n            style : {...},\r\n            ...\r\n        })\r\n    );\r\n    \r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/uooo/zrender.git"
  },
  "version": "2.1.1"
}
